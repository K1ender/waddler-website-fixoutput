import Callout from '@mdx/Callout.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import YoutubeCards from '@mdx/YoutubeCards.astro';
import Npm from '@mdx/Npm.astro';
import Section from '@mdx/Section.astro';

# Waddler

Waddler - is a thin SQL client wrapper with modern API inspired by [`postgresjs`](https://github.com/porsager/postgres) and based on ES6 Tagged Template Strings.

> You don't need to learn an api for db clients; just use the `sql` template tag for everything

Waddler is our vision of a modern, all-in-one client for any database dialect.
It doesn't perform any specific mappings to or from a database, doesn't handle complex query building, and doesn't parse queries.
Waddler simply unifies communication with your database using any client you 
choose - whether it's a simple TCP connection or an HTTP-based DB client.

We support all the dialects and drivers that [Drizzle](https://orm.drizzle.team/docs/get-started) supports

You can check a full list of clients you can use - [here](/docs/get-started)

```ts
import { waddler } from "waddler/...";

const sql = waddler({ dbUrl: process.env.DATABASE_URL });

await sql`select 1`;
```

Waddler API consists of `sql` template, `sql.identifier`, `sql.values` and `sql.raw` operators:

[SQL template](/docs/sql-template) protects you from SQL injections:
<Section>
```ts
await sql`select * from users where id = ${10}`;
```
```sql
select * from users where id = $1;
-- 10 will be passed as a param [10]
```
</Section>

[SQL identifier](/docs/sql-identifier) lets you conveniently provide `schema`, `table` and `column` names to the query. Those will be automatically properly escaped:

<Section>
```ts
await sql`select * from ${sql.identifier("users")}`;
await sql`select * from ${sql.identifier({ schema: "public", table: "users" })}`;

const userIdColumn = sql.identifier({ schema: "public", table: "users", column: "id", as: "userId"});
await sql`select ${userIdColumn} from "users"`;
```
```sql
select * from "users";
select * from "public"."users";
select * from "public"."users"."id" as "userId" from "users";
```
</Section>

[SQL values](/docs/sql-values) API is designed to help you with insert statements:
<Section>
```ts
const tuples = [["Dan", 27], ["Oleksii", 25]];
await sql`insert into "users" ("name", "age") values ${sql.values(tuples)}`;
```
```sql
insert into "users" ("name", "age") values ('Dan', 27), ('Oleksii', 25);
```
</Section>

[SQL raw](/docs/sql-raw) lets you dynamically build SQL by embedding raw strings:
<Section>
```ts
const listUsers = async (filter: string | undefined) => {
  const whereClause = filter ? sql.raw(` where ${filter}`) : sql.raw("");
  return sql`select * from "users"${whereClause}`;
}

await listUsers(`"id" = 10`);
await listUsers(`"name" = 'Dan'`);
await listUsers();
```
```sql
select * from "users" where "id" = 10;
select * from "users" where "name" = 'Dan';
select * from "users";
```
</Section>

